NAMESPACE Unit2.EM4
FUNCTION_BLOCK Sequence
TITLE = EquipmentC_StateActions
{ S7_Optimized_Access := 'TRUE' ; Published := 'FALSE' }
VERSION : 0.1
//State model of equipment module following the OMAC standard.
   VAR 
      statSelectedJobNumber { ExternalWritable := 'False'} : DInt;   // 已评估的作业编号 / Evaluated Job Number
      instSequenceSCLControl { ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LAF_ControlSclSequence;   // 序列SCL控制实例 / Sequence SCL Control Instance
      instSequenceSCLStatus { ExternalWritable := 'False'; S7_SetPoint := 'False'} : _.LAF_StatusSclSequence;   // 序列SCL状态实例 / Sequence SCL Status Instance
      statVfdSportsInc { ExternalWritable := 'False'; S7_SetPoint := 'True'} : Int;   // VFD运动增量 / VFD Sports Increment
      statVfdSportsIncEnable { ExternalWritable := 'False'} : Bool;   // VFD运动增量使能 / VFD Sports Increment Enable
      statCylinderOnHome { ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // 气缸在原位 / Cylinder On Home Position
      statAxisOnHome { ExternalWritable := 'False'} : Bool;   // 轴在原位 / Axis On Home Position
      statCycleMovexPos { ExternalWritable := 'False'} : Bool;   // 循环移动X位置 / Cycle Move X Position
      timeDelayTrigger {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Array[0..1] of TON_TIME;   // 延时触发器 / Time Delay Trigger
      statAxisPosHomeDone { ExternalWritable := 'False'; S7_SetPoint := 'True'} : Bool;   // 轴位置回原点完成 / Axis Position Home Done
      statCylinderHomeDone { ExternalWritable := 'False'} : Bool;   // 气缸回原点完成 / Cylinder Home Done
      statCylinderWorkDone { ExternalWritable := 'False'} : Bool;   // 气缸工作完成 / Cylinder Work Done
      statRowTwoOn { ExternalWritable := 'False'} : Bool;   // 第二行开启 / Row Two On
      statXyzTransferEnable { ExternalWritable := 'False'} : Bool;   // XYZ传输使能 / XYZ Transfer Enable
      statxDistanceIndex { ExternalWritable := 'False'} : Int;   // X距离索引 / X Distance Index
      statyDistanceIndex { ExternalWritable := 'False'} : Int;   // Y距离索引 / Y Distance Index
      statScratchCellsInfo { ExternalWritable := 'False'} : Array[0..3] of Bool;   // 刮擦单元信息 / Scratch Cells Information
      statCurrentScratchCellIndexOnRow { ExternalWritable := 'False'} : Int;   // 当前行上的刮擦单元索引 / Current Scratch Cell Index On Row
      statCurrentScratchCellIndex { ExternalWritable := 'False'} : Int;   // 当前刮擦单元索引 / Current Scratch Cell Index
      statLastScratch { ExternalWritable := 'False'} : Bool;   // 最后刮擦 / Last Scratch
      statPlasticStepEnable { ExternalWritable := 'False'} : Bool;   // 塑料步骤使能 / Plastic Step Enable
      statNgConveyorEnable { ExternalWritable := 'False'} : Bool;   // NG输送机使能 / NG Conveyor Enable
      statRecoverOn { ExternalWritable := 'False'} : Bool;   // 恢复开启 / Recover On
      statRecoverStep { ExternalWritable := 'False'} : DInt;   // 恢复步骤 / Recover Step
      statCurrentStepPrevious { ExternalWritable := 'False'} : DInt;   // 前一步骤 / Current Step Previous
      statStepFirstCall { ExternalWritable := 'False'} : Bool;   // 步骤首次调用 / Step First Call
      statPlasticNextScratchCellIndex : Int;   // 塑料下一个刮擦单元索引 / Plastic Next Scratch Cell Index
      instRecordRecoverStep { ExternalWritable := 'False'} : EXCHANGETRAY_RecordRecoverStep;   // 记录恢复步骤实例 / Record Recover Step Instance
   END_VAR

   VAR_TEMP 
      tempCm1PosDone : Bool;   // CM1位置完成临时变量 / CM1 Position Done Temporary
      tempCm2PosDone : Bool;   // CM2位置完成临时变量 / CM2 Position Done Temporary
      tempCm3PosDone : Bool;   // CM3位置完成临时变量 / CM3 Position Done Temporary
      tempCellSize : Int;   // 单元尺寸临时变量 / Cell Size Temporary
      tempHalfCellSize : Int;   // 半单元尺寸临时变量 / Half Cell Size Temporary
      tempCurrentPosIndex : Int;   // 当前位置索引临时变量 / Current Position Index Temporary
      tempNextPosIndex : Int;   // 下一位置索引临时变量 / Next Position Index Temporary
      tempConstraintNextScratchCellIndex : Int;   // 约束下一个刮擦单元索引临时变量 / Constraint Next Scratch Cell Index Temporary
      tempWithorWithoutCellDetections : Array[0..3] of Bool;   // 有无单元检测临时变量 / With or Without Cell Detections Temporary
      tempLoopIndex : Int;   // 循环索引临时变量 / Loop Index Temporary
      tempValidCellIndex : Int;   // 有效单元索引临时变量 / Valid Cell Index Temporary
      tempCellsInfo : Array[0..99] of Bool;   // 单元信息临时变量 / Cells Info Temporary
      tempPlasticStep : Bool;   // 塑料步骤临时变量 / Plastic Step Temporary
      tempNgConveyorStep : Bool;   // NG输送机步骤临时变量 / NG Conveyor Step Temporary
      tempRowNumber : Int;   // 行号临时变量 / Row Number Temporary
      tempCm4Enable : Bool;   // CM4使能临时变量 / CM4 Enable Temporary
      tempCm5Enable : Bool;   // CM5使能临时变量 / CM5 Enable Temporary
      tempCm6Enable : Bool;   // CM6使能临时变量 / CM6 Enable Temporary
      tempCm7Enable : Bool;   // CM7使能临时变量 / CM7 Enable Temporary
      tempCm4CylinderRecoverStatus : _.LBC_Simple_typeTwoWayActuatorControlNodeMonitoring;   // CM4气缸恢复状态临时变量 / CM4 Cylinder Recover Status Temporary
      tempCm4CylinderRecoverCommand : _.LBC_Simple_typeTwoWayActuatorControlNodeCommands;   // CM4气缸恢复命令临时变量 / CM4 Cylinder Recover Command Temporary
      tempCm5CylinderRecoverStatus : _.LBC_Simple_typeTwoWayActuatorControlNodeMonitoring;   // CM5气缸恢复状态临时变量 / CM5 Cylinder Recover Status Temporary
      tempCm5CylinderRecoverCommand : _.LBC_Simple_typeTwoWayActuatorControlNodeCommands;   // CM5气缸恢复命令临时变量 / CM5 Cylinder Recover Command Temporary
      tempCm6CylinderRecoverStatus : _.LBC_Simple_typeTwoWayActuatorControlNodeMonitoring;   // CM6气缸恢复状态临时变量 / CM6 Cylinder Recover Status Temporary
      tempCm6CylinderRecoverCommand : _.LBC_Simple_typeTwoWayActuatorControlNodeCommands;   // CM6气缸恢复命令临时变量 / CM6 Cylinder Recover Command Temporary
      tempCm7CylinderRecoverStatus : _.LBC_Simple_typeTwoWayActuatorControlNodeMonitoring;   // CM7气缸恢复状态临时变量 / CM7 Cylinder Recover Status Temporary
      tempCm7CylinderRecoverCommand : _.LBC_Simple_typeTwoWayActuatorControlNodeCommands;   // CM7气缸恢复命令临时变量 / CM7 Cylinder Recover Command Temporary
      tempCm1AxisRecoverCommandConfiguration : _.LBC_typeAxisSimpleControlCommandConfiguration_1;   // CM1轴恢复命令配置临时变量 / CM1 Axis Recover Command Configuration Temporary
      tempCm2AxisRecoverCommandConfiguration : _.LBC_typeAxisSimpleControlCommandConfiguration_1;   // CM2轴恢复命令配置临时变量 / CM2 Axis Recover Command Configuration Temporary
      tempCm3AxisRecoverCommandConfiguration : _.LBC_typeAxisSimpleControlCommandConfiguration_1;   // CM3轴恢复命令配置临时变量 / CM3 Axis Recover Command Configuration Temporary
   END_VAR

   VAR CONSTANT 
      STEP_IDLE : DInt := 1;   // 空闲步骤 / Idle Step
      STEP_101 : DInt := 101;   // 初始化参数步骤 / Initialize Parameters Step
      STEP_102 : DInt := 102;   // 更新位置步骤 / Update Position Step
      STEP_103 : DInt := 103;   // X-Y轴移动到准备位置步骤 / X-Y Axis Move to Ready Position Step
      STEP_104 : DInt := 104;   // 等待捕获单元步骤 / Wait Catch Cells Step
      STEP_105 : DInt := 105;   // 气缸工作步骤 / Cylinder On Work Step
      STEP_106 : DInt := 106;   // Z轴上升步骤 / Z Axis Move Up Step
      STEP_107 : DInt := 107;   // 传输使能到EM2步骤 / Transfer Enable to EM2 Step
      STEP_109 : DInt := 109;   // 保留步骤 / Reserved Step
      STEP_110 : DInt := 110;   // 塑料移动步骤 / Plastic Moving Step
      STEP_111 : DInt := 111;   // 等待EM5传输使能步骤 / Wait EM5 Transfer Enable Step
      STEP_120 : DInt := 120;   // NG输送机移动步骤 / NG Conveyor Moving Step
      STEP_112 : DInt := 112;   // 放下单元，气缸回原位步骤 / Put Down Cells, Cylinder Go Home Step
      STEP_113 : DInt := 113;   // Z轴上升步骤 / Z Axis Move Up Step
      STEP_114 : DInt := 114;   // 保留步骤 / Reserved Step
      STEP_115 : DInt := 115;   // 保留步骤 / Reserved Step
      STEP_1202 : DInt := 1202;   // 保留步骤 / Reserved Step
      STEP_121 : DInt := 121;   // 等待NG输送机传输使能步骤 / Wait NG Conveyor Transfer Enable Step
      STEP_122 : DInt := 122;   // 等待放下单元，气缸回原位步骤 / Wait Put Down Cells, Cylinder Go Home Step
      STEP_123 : DInt := 123;   // Z轴上升步骤 / Z Axis Move Up Step
      STEP_124 : DInt := 124;   // 保留步骤 / Reserved Step
      STEP_130 : DInt := 130;   // 检查完成步骤 / Check Completion Step
      STEP_131 : DInt := 131;   // 保留步骤 / Reserved Step
      STEP_132 : DInt := 132;   // 保留步骤 / Reserved Step
      STEP_201 : DInt := 201;   // 停止步骤 / Stopping Step
      STEP_301 : DInt := 301;   // 保持步骤 / Holding Step
      STEP_401 : DInt := 401;   // 解除保持步骤 / Unholding Step
      STEP_501 : DInt := 501;   // 休息步骤 / Resting Step
      STEP_701 : DInt := 701;   // 恢复步骤 / Recovery Step
      STEP_601 : DInt := 601;   // 启动初始化信号步骤 / Starting Init Signal Step
      STEP_602 : DInt := 602;   // 启动初始化设备步骤 / Starting Init Equipment Step
      STEP_IMMEDIATE_STOP : DInt := 901;   // 当序列触发立即停止命令时执行的步骤（即当单元处于中止状态时）/ Step executed when an immediate stop command is triggered for the sequence (i.e. when unit is in state aborting)
      TO_DO_INSERT_CONDITION_FOR_TRANSITION_HERE : Bool := TRUE;   // 模板：添加条件 / Template: Add conditions
      VFD_CW : DInt := 1;   // VFD顺时针 / VFD Clockwise
      VFD_CCW : DInt := -1;   // VFD逆时针 / VFD Counter-Clockwise
      "24SIZE" : Int := 24;   // 24尺寸常量 / 24 Size Constant
      "36SIZE" : Int := 36;   // 36尺寸常量 / 36 Size Constant
      WITHORWITHOUTDETECT1ERROR : Int := 36;   // 有无检测1错误代码 / With or Without Detect 1 Error Code
      WITHORWITHOUTDETECT2ERROR : Int := 37;   // 有无检测2错误代码 / With or Without Detect 2 Error Code
      WITHORWITHOUTDETECT3ERROR : Int := 38;   // 有无检测3错误代码 / With or Without Detect 3 Error Code
      WITHORWITHOUTDETECT4ERROR : Int := 39;   // 有无检测4错误代码 / With or Without Detect 4 Error Code
      RECOVERERROR : Int := 40;   // 恢复错误代码 / Recover Error Code
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	    //===============================================================================
	    // (company)/ (c)Copyright (year)
	    //-------------------------------------------------------------------------------
	    // Title:            EquipmentC_StateActions
	    // Comment/Function: 设备C的状态动作控制序列 / State actions control sequence for Equipment C
	    // Library/Family:   ExchangeTrayProject
	    // Author:           Automation Team
	    // Tested with:      TIA Portal V17
	    // Engineering:      TIA Portal V17
	    // Restrictions:     无 / None
	    // Requirements:     西门子S7-1500 PLC / Siemens S7-1500 PLC
	    //-------------------------------------------------------------------------------
	    // Change log table:
	    // Version  | Date       | Expert in charge        | Changes applied
	    //----------|------------|-------------------------|-----------------------------
	    // 01.00.00 | dd.mm.yyyy | (name of expert)        | First released version
	    //===============================================================================
	END_REGION BLOCK INFO HEADER
	
	REGION DESCRIPTION
	(/*
	此功能块实现设备C的状态动作控制序列，遵循OMAC标准状态模型。
	主要功能包括：
	1. 初始化设备参数
	2. 控制气缸和轴的运动
	3. 处理塑料和NG输送机的传输
	4. 实现恢复功能
	
	This function block implements the state actions control sequence for Equipment C, 
	following the OMAC standard state model.
	Main functions include:
	1. Initialize equipment parameters
	2. Control cylinder and axis movements
	3. Handle plastic and NG conveyor transfers
	4. Implement recovery functions
	*/)
	END_REGION DESCRIPTION
	REGION intput
	    #tempCellSize := _.Global.Data.parameter.material.Unit2.contraint.parameters.specification[_.Global.Data.parameter.material.Unit2.contraint.parameters.selectSpecification].traySize;
	    #tempConstraintNextScratchCellIndex := _.Global.Data.material.Unit2.contraint.monitor.cellsInfo.nextScratchCellIndex;
	    #tempWithorWithoutCellDetections[0] := _.Unit2.EM4.ControlNodes.cm8SignalTM.monitoring.withOrWithoutCellDetectionU2EM4_1;
	    #tempWithorWithoutCellDetections[1] := _.Unit2.EM4.ControlNodes.cm8SignalTM.monitoring.withOrWithoutCellDetectionU2EM4_2;
	    #tempWithorWithoutCellDetections[2] := _.Unit2.EM4.ControlNodes.cm8SignalTM.monitoring.withOrWithoutCellDetectionU2EM4_3;
	    #tempWithorWithoutCellDetections[3] := _.Unit2.EM4.ControlNodes.cm8SignalTM.monitoring.withOrWithoutCellDetectionU2EM4_4;
	    #tempCellsInfo := _.Global.Data.material.Unit2.contraint.monitor.cellsInfo.cellsResult;
	    #tempHalfCellSize := #tempCellSize;
	    
	END_REGION
	IF HmiInterface.sequence.commands.setSingleStepMode THEN
	    IF NOT HmiInterface.sequence.commands.nextStep THEN
	        ControlNodes.sequence.status.nextStep := ControlNodes.sequence.status.currentStep;
	    END_IF;
	END_IF;
	
	REGION Sequence control
	    // General control of the sequence
	    #instSequenceSCLControl(idleStep := #STEP_IDLE,
	                            stoppedStep := #STEP_IMMEDIATE_STOP,
	                            resetJobs => ControlNodes.jobs.commands.reset,
	                            hmiInterface := HmiInterface.sequence,
	                            sequence := ControlNodes.sequence);
	END_REGION Sequence control
	
	IF #statCurrentStepPrevious <> ControlNodes.sequence.status.currentStep THEN
	    #statStepFirstCall := FALSE;
	END_IF;
	#statCurrentStepPrevious := ControlNodes.sequence.status.currentStep;
	
	
	REGION Steps
	    //===============================================================================
	    // 状态机实现 / State machine implementation
	    // 实现设备C的状态转换逻辑 / Implements the state transition logic for Equipment C
	    // 主要功能: / Main functions:
	    // 1. 处理设备启动、停止、保持等基本操作 / Handle basic operations like start, stop, hold
	    // 2. 控制气缸和轴的运动 / Control cylinder and axis movements
	    // 3. 处理塑料和NG输送机的传输 / Handle plastic and NG conveyor transfers
	    // 4. 实现恢复功能 / Implement recovery functions
	    //===============================================================================
	    // Only execute sequence if active
	    IF ControlNodes.sequence.status.seqActive THEN
	        
	        // Determine the current step
	        CASE ControlNodes.sequence.status.currentStep OF
	                
	            #STEP_IDLE:
	                // If a new job is activated, move to the first step of that job                   
	                IF ControlNodes.sequence.status.executionEnabled THEN
	                    CASE ControlNodes.jobs.commands.setJobNumber OF
	                        _.U2EM4_JOB_EXECUTE:
	                            ControlNodes.sequence.status.nextStep := #STEP_101;
	                        _.U2EM4_JOB_STOPPING:
	                            ControlNodes.sequence.status.nextStep := #STEP_201;
	                        _.U2EM4_JOB_HOLODING:
	                            ControlNodes.sequence.status.nextStep := #STEP_301;
	                        _.U2EM4_JOB_UNHOLODING:
	                            ControlNodes.sequence.status.nextStep := #STEP_401;
	                        _.U2EM4_JOB_RESTING:
	                            ControlNodes.sequence.status.nextStep := #STEP_501;
	                        _.U2EM4_JOB_STARTING:
	                            ControlNodes.sequence.status.nextStep := #STEP_601;
	                        _.U2EM4_JOB_RECOVER:
	                            ControlNodes.sequence.status.nextStep := #STEP_701;
	                    END_CASE;
	                    
	                END_IF;
	                (* ControlNodes.cm1Vfd206.sinaControlNode.commandConfiguration.referenceSpeed :=
	                 HmiInterface.cm1Vfd206.commandConfiguration.referenceSpeed := "_".Global.Data.parameter.U2EM2.cm1Vfd206.general.refSpeed; *)
	                REGION ########JOB_STARTING_Step600
	                    
	                    
	                END_REGION
	            #STEP_601:
	                REGION STARTING_initSimSignal_Step601
	                    ControlNodes.cm8SignalTM.reset := true;
	                    ControlNodes.sequence.status.nextStep := #STEP_602;
	                END_REGION ;
	            #STEP_602:
	                REGION #STEP_602
	                    IF NOT _.Global.Data.unit[1].specialFunctions.specialFunction10 THEN
	                        #statCylinderHomeDone := false;
	                        EXCHANGETRAY_Em4CylindersOperate(goHome := NOT #statCylinderHomeDone,
	                                                         goWork := false,
	                                                         cm4Enable := 1,
	                                                         cm5Enable := 1,
	                                                         cm6Enable := 1,
	                                                         cm7Enable := 1,
	                                                         homeDone => #statCylinderHomeDone,
	                                                         workDone => #statCylinderWorkDone);
	                        EXCHANGETRAY_Em4AxisGoHome(homeDone => #statAxisOnHome);
	                        IF #statAxisOnHome AND #statCylinderHomeDone THEN
	                            ControlNodes.sequence.status.nextStep := #STEP_IDLE;
	                        END_IF;
	                        #statRowTwoOn := FALSE;
	                    ELSE
	                        ControlNodes.sequence.status.nextStep := #STEP_IDLE;
	                    END_IF;
	                    
	                END_REGION
	                
	                REGION ########JOB_RESTING_Step500
	                    
	                    
	                END_REGION
	            #STEP_501:
	                ControlNodes.cm8SignalTM.reset := true;
	                ControlNodes.sequence.status.nextStep := #STEP_IDLE;
	            #STEP_401:
	                REGION UNHOLODING_Step401
	                    
	                    
	                    ControlNodes.sequence.status.nextStep := #STEP_IDLE;
	                END_REGION ;
	                REGION ########JOB_HOLODING_Step300
	                    
	                    
	                END_REGION
	            #STEP_301:
	                REGION HOLODING_Step301
	                    #statStepFirstCall := FALSE;
	                    
	                    
	                    ;
	                END_REGION ;
	                REGION ########JOB_STOPPING_Step200
	                    
	                    
	                END_REGION
	            #STEP_201:
	                REGION STEP_201 stopping
	                    #statStepFirstCall := FALSE;
	                    ControlNodes.cm1AxisControl.commands.stop := TRUE;
	                    ControlNodes.cm2AxisControl.commands.stop := TRUE;
	                    ControlNodes.cm3AxisControl.commands.stop := TRUE;
	                    IF ControlNodes.jobs.commands.setJobNumber = _.U2EM4_JOB_EXECUTE THEN
	                        #instRecordRecoverStep.step := ControlNodes.sequence.previousSteps[2].step;
	                        #instRecordRecoverStep.saveRecord := true;
	                    END_IF;
	                    IF #instRecordRecoverStep.saveDone THEN
	                        #instRecordRecoverStep.saveRecord := FALSE;
	                        ;
	                    END_IF;
	                    
	                    IF ControlNodes.cm1AxisControl.monitoring.statusWord.bit06_Done
	                        AND
	                        ControlNodes.cm1AxisControl.monitoring.statusWord.bit06_Done
	                        AND
	                        ControlNodes.cm1AxisControl.monitoring.statusWord.bit06_Done
	                    THEN
	                        ControlNodes.sequence.status.nextStep := #STEP_IDLE;
	                        ;
	                    END_IF;
	                    
	                END_REGION
	                
	                REGION ########RECOVERING_JOB
	                END_REGION
	            #STEP_701:
	                REGION Step_701
	                    // Statement section REGION
	                    #tempCm4CylinderRecoverStatus := #instRecordRecoverStep.outCm4Cylinder.monitoring;
	                    #tempCm4CylinderRecoverCommand := #instRecordRecoverStep.outCm4Cylinder.commands;
	                    #tempCm5CylinderRecoverStatus := #instRecordRecoverStep.outCm5Cylinder.monitoring;
	                    #tempCm5CylinderRecoverCommand := #instRecordRecoverStep.outCm5Cylinder.commands;
	                    #tempCm6CylinderRecoverStatus := #instRecordRecoverStep.outCm6Cylinder.monitoring;
	                    #tempCm6CylinderRecoverCommand := #instRecordRecoverStep.outCm6Cylinder.commands;
	                    #tempCm7CylinderRecoverStatus := #instRecordRecoverStep.outCm7Cylinder.monitoring;
	                    #tempCm7CylinderRecoverCommand := #instRecordRecoverStep.outCm7Cylinder.commands;
	                    #tempCm1AxisRecoverCommandConfiguration := #instRecordRecoverStep.outCm1AxisControl.commandConfiguration;
	                    #tempCm2AxisRecoverCommandConfiguration := #instRecordRecoverStep.outCm2AxisControl.commandConfiguration;
	                    #tempCm3AxisRecoverCommandConfiguration := #instRecordRecoverStep.outCm3AxisControl.commandConfiguration;
	                    
	                    IF #tempCm4CylinderRecoverStatus.inHomePos <> ControlNodes.cm4Cylinder.monitoring.inHomePos
	                        OR
	                        #tempCm5CylinderRecoverStatus.inHomePos <> ControlNodes.cm5Cylinder.monitoring.inHomePos
	                        OR
	                        #tempCm6CylinderRecoverStatus.inHomePos <> ControlNodes.cm6Cylinder.monitoring.inHomePos
	                        OR
	                        #tempCm7CylinderRecoverStatus.inHomePos <> ControlNodes.cm7Cylinder.monitoring.inHomePos
	                        OR
	                        #tempCm4CylinderRecoverStatus.inWorkPos <> ControlNodes.cm4Cylinder.monitoring.inWorkPos
	                        OR
	                        #tempCm5CylinderRecoverStatus.inWorkPos <> ControlNodes.cm5Cylinder.monitoring.inWorkPos
	                        OR
	                        #tempCm6CylinderRecoverStatus.inWorkPos <> ControlNodes.cm6Cylinder.monitoring.inWorkPos
	                        OR
	                        #tempCm7CylinderRecoverStatus.inWorkPos <> ControlNodes.cm7Cylinder.monitoring.inWorkPos
	                        OR
	                        NOT _.LGF_CompareLReal(valueA := #tempCm1AxisRecoverCommandConfiguration.posAbsolute.position, valueB := ControlNodes.cm1AxisControl.monitoring.position)
	                        OR
	                        NOT _.LGF_CompareLReal(valueA := #tempCm2AxisRecoverCommandConfiguration.posAbsolute.position, valueB := ControlNodes.cm2AxisControl.monitoring.position)
	                        OR
	                        NOT _.LGF_CompareLReal(valueA := #tempCm3AxisRecoverCommandConfiguration.posAbsolute.position, valueB := ControlNodes.cm3AxisControl.monitoring.position)
	                        
	                    THEN
	                        _.Unit2.Alarms.errorStop[#RECOVERERROR] := TRUE;
	                        #statRecoverOn := FALSE;
	                        #statRecoverStep := #STEP_IDLE;
	                    ELSE
	                        #statRecoverOn := TRUE;
	                        #statRecoverStep := #instRecordRecoverStep.step;
	                        ControlNodes.sequence.status.nextStep := #STEP_IDLE;
	                    END_IF;
	                    _.Global.Data.unit[1].specialFunctions.specialFunction10 := FALSE;
	                END_REGION ;
	                
	                REGION ########JOB_EXECUTE_Step100
	                    
	                END_REGION
	            #STEP_101:
	                REGION STEP_101 initPara
	                    // 初始化参数步骤 / Initialize parameters step
	                    // 检查是否需要从恢复状态继续 / Check if need to continue from recovery state
	                    IF #statRecoverOn THEN
	                        ControlNodes.sequence.status.nextStep := #statRecoverStep;
	                        #statRecoverOn := false;
	                    ELSE
	                        // 初始化变量 / Initialize variables
	                        #statRowTwoOn := FALSE;  // 重置行状态 / Reset row state
	                        #tempConstraintNextScratchCellIndex :=
	                        #statPlasticNextScratchCellIndex := 0;  // 重置刮擦单元索引 / Reset scratch cell index
	                        ControlNodes.sequence.status.nextStep := #STEP_102;  // 转到更新位置步骤 / Go to update position step
	                    END_IF;
	                    
	                END_REGION
	                
	            #STEP_102:
	                REGION STEP_102 update position
	                    // 更新位置步骤 / Update position step
	                    // 根据单元尺寸和当前索引更新各轴位置 / Update axis positions based on cell size and current index
	                    
	                    REGION get cells information
	                        // 获取单元信息区域 / Get cells information region
	                        #statCurrentScratchCellIndex := #tempConstraintNextScratchCellIndex;  // 设置当前刮擦单元索引 / Set current scratch cell index
	                        #statLastScratch := #tempConstraintNextScratchCellIndex + 4 >= #tempCellSize;  // 检查是否是最后一次刮擦 / Check if it's the last scratch
	                        
	                        // 计算当前行上的单元索引 / Calculate cell index on current row
	                        IF NOT #statRowTwoOn THEN
	                            #statCurrentScratchCellIndexOnRow := #tempConstraintNextScratchCellIndex / 8;
	                        END_IF;
	                        
	                        // 设置X轴距离索引 / Set X distance index
	                        #statxDistanceIndex := #statCurrentScratchCellIndexOnRow;
	                        
	                        REGION 24 size setting
	                            // 24尺寸单元设置 / 24 size cell settings
	                            IF #tempCellSize = #"24SIZE" THEN
	                                
	                                REGION position Settings
	                                    // Y轴位置设置 / Y axis position settings
	                                    _.Unit2.EM4.ControlNodes.cm2AxisControl.commandConfiguration.posAbsolute.position :=
	                                    Config.em4Parameters.cm2Axis120.production.distanceList[0 + #statyDistanceIndex].position;
	                                    _.Unit2.EM4.ControlNodes.cm2AxisControl.commandConfiguration.posAbsolute.velocity :=
	                                    Config.em4Parameters.cm2Axis120.production.distanceList[0].velocity;
	                                    
	                                    // Z轴位置设置 / Z axis position settings
	                                    _.Unit2.EM4.ControlNodes.cm3AxisControl.commandConfiguration.posAbsolute.position :=
	                                    Config.em4Parameters.cm3Axis121.production.distanceList[0].position;
	                                    _.Unit2.EM4.ControlNodes.cm3AxisControl.commandConfiguration.posAbsolute.velocity :=
	                                    Config.em4Parameters.cm3Axis121.production.distanceList[0].velocity;
	                                    
	                                    // X轴位置设置 / X axis position settings
	                                    _.Unit2.EM4.ControlNodes.cm1AxisControl.commandConfiguration.posAbsolute.position :=
	                                    Config.em4Parameters.cm1Axis119.production.distanceList[30 + #statxDistanceIndex].position;
	                                    _.Unit2.EM4.ControlNodes.cm1AxisControl.commandConfiguration.posAbsolute.velocity :=
	                                    Config.em4Parameters.cm1Axis119.production.distanceList[0].velocity;
	                                    
	                                END_REGION
	                            END_IF;
	                            
	                        END_REGION
	                        
	                        REGION 36 size setting
	                            // 36尺寸单元设置 / 36 size cell settings
	                            IF #tempCellSize = #"36SIZE" THEN
	                                REGION position settings
	                                    // Y轴位置设置 / Y axis position settings
	                                    _.Unit2.EM4.ControlNodes.cm2AxisControl.commandConfiguration.posAbsolute.position :=
	                                    Config.em4Parameters.cm2Axis120.production.distanceList[3 + #statyDistanceIndex].position;
	                                    _.Unit2.EM4.ControlNodes.cm2AxisControl.commandConfiguration.posAbsolute.velocity :=
	                                    Config.em4Parameters.cm2Axis120.production.distanceList[3].velocity;
	                                    
	                                    // Z轴位置设置 / Z axis position settings
	                                    _.Unit2.EM4.ControlNodes.cm3AxisControl.commandConfiguration.posAbsolute.position :=
	                                    Config.em4Parameters.cm3Axis121.production.distanceList[3].position;
	                                    _.Unit2.EM4.ControlNodes.cm3AxisControl.commandConfiguration.posAbsolute.velocity :=
	                                    Config.em4Parameters.cm3Axis121.production.distanceList[3].velocity;
	                                    
	                                    // X轴位置设置 / X axis position settings
	                                    _.Unit2.EM4.ControlNodes.cm1AxisControl.commandConfiguration.posAbsolute.position :=
	                                    Config.em4Parameters.cm1Axis119.production.distanceList[40 + #statxDistanceIndex].position;
	                                    _.Unit2.EM4.ControlNodes.cm1AxisControl.commandConfiguration.posAbsolute.velocity :=
	                                    Config.em4Parameters.cm1Axis119.production.distanceList[0].velocity;
	                                END_REGION
	                                
	                            END_IF;
	                        END_REGION
	                        
	                    END_REGION
	                    
	                    // 转到X-Y轴移动到准备位置步骤 / Go to X-Y axis move to ready position step
	                    ControlNodes.sequence.status.nextStep := #STEP_103;
	                    
	                END_REGION ;
	                
	                
	                
	            #STEP_103:
	                REGION STEP_103 X_Y_GOTO_READY_POSITION
	                    // X-Y轴移动到准备位置步骤 / X-Y axis move to ready position step
	                    // 发送X/Y轴绝对位置移动命令 / Send X/Y axis absolute position move commands
	                    ControlNodes.cm1AxisControl.commands.posAbsolute := TRUE;  // X轴绝对位置移动 / X axis absolute position move
	                    ControlNodes.cm2AxisControl.commands.posAbsolute := TRUE;  // Y轴绝对位置移动 / Y axis absolute position move
	                    
	                    // 检查X/Y轴是否到达目标位置 / Check if X/Y axes reached target positions
	                    #tempCm1PosDone := _.LGF_CompareLReal(valueA := ControlNodes.cm1AxisControl.commandConfiguration.posAbsolute.position,
	                                                          valueB := ControlNodes.cm1AxisControl.monitoring.position);
	                    #tempCm2PosDone := _.LGF_CompareLReal(valueA := ControlNodes.cm2AxisControl.commandConfiguration.posAbsolute.position,
	                                                          valueB := ControlNodes.cm2AxisControl.monitoring.position);
	                    
	                    // 当X/Y轴都到达目标位置时转到下一步 / When both X/Y axes reached, go to next step
	                    IF #tempCm1PosDone AND #tempCm2PosDone THEN
	                        ControlNodes.sequence.status.nextStep := #STEP_104;  // 转到等待捕获单元步骤 / Go to wait catch cells step
	                        ;
	                    END_IF;
	                    
	                    ;
	                END_REGION
	                
	                ;
	                
	                
	            #STEP_104:
	                REGION STEP_104 wait_catch_cells
	                    // 等待捕获单元步骤 / Wait catch cells step
	                    // 检查约束滚轮传输使能信号 / Check constraint roller transfer enable signal
	                    IF _.Unit2.EmNodes.emRelations.EM4.recieve.constraintRoller.req.transferEnable THEN
	                        REGION import cells Infor result 
	                            // 根据单元尺寸导入单元信息 / Import cells information based on cell size
	                            IF #tempCellSize = #"24SIZE" THEN
	                                // 24尺寸单元处理 / 24 size cell processing
	                                FOR #tempLoopIndex := 0 TO 3 DO
	                                    #statScratchCellsInfo[#tempLoopIndex] :=
	                                    #tempCellsInfo[#tempLoopIndex + #statCurrentScratchCellIndex];  // 导入4个单元信息 / Import 4 cells information
	                                END_FOR;
	                            END_IF;
	                            IF #tempCellSize = #"36SIZE" THEN
	                                // 36尺寸单元处理 / 36 size cell processing
	                                IF #tempConstraintNextScratchCellIndex + 4 < #tempCellSize THEN
	                                    // 常规情况导入4个单元信息 / Normal case import 4 cells information
	                                    FOR #tempLoopIndex := 0 TO 3 DO
	                                        #statScratchCellsInfo[#tempLoopIndex] :=
	                                        #tempCellsInfo[#tempLoopIndex + #statCurrentScratchCellIndex];
	                                    END_FOR;
	                                ELSE
	                                    // 最后位置导入2个单元信息 / Last position import 2 cells information
	                                    FOR #tempLoopIndex := 0 TO 1 DO
	                                        #statScratchCellsInfo[#tempLoopIndex] :=
	                                        #tempCellsInfo[#tempLoopIndex + #statCurrentScratchCellIndex];
	                                    END_FOR;
	                                END_IF;
	                            END_IF;
	                        END_REGION
	                        
	                        REGION z_move_liftdown
	                            // Z轴下降区域 / Z axis move down region
	                            ControlNodes.cm3AxisControl.commands.posAbsolute := TRUE;  // 发送Z轴绝对位置移动命令 / Send Z axis absolute position move command
	                            IF _.LGF_CompareLReal(valueA := ControlNodes.cm3AxisControl.commandConfiguration.posAbsolute.position,
	                                                      valueB := ControlNodes.cm3AxisControl.monitoring.position) THEN
	                                ControlNodes.sequence.status.nextStep := #STEP_105;  // 转到气缸工作步骤 / Go to cylinder on work step
	                            END_IF;
	                        END_REGION
	                        
	                        ;
	                    END_IF;
	                    
	                    ;
	                END_REGION ;
	                ;
	                
	            #STEP_105:
	                REGION STEP_105 Cylinder_OnWork
	                    #statCylinderWorkDone := false;
	                    EXCHANGETRAY_Em4CylindersOperate(goHome := false,
	                                                     goWork := NOT #statCylinderWorkDone,
	                                                     cm4Enable := 1,
	                                                     cm5Enable := 1,
	                                                     cm6Enable := 1,
	                                                     cm7Enable := 1,
	                                                     homeDone => #statCylinderHomeDone,
	                                                     workDone => #statCylinderWorkDone);
	                    
	                END_REGION
	                
	                IF #statCylinderWorkDone THEN
	                    REGION check_catchcells_count
	                        
	                        REGION raise_error by withorwithout
	                            _.Unit2.Alarms.errorStop[#WITHORWITHOUTDETECT1ERROR] := NOT #tempWithorWithoutCellDetections[0];
	                            _.Unit2.Alarms.errorStop[#WITHORWITHOUTDETECT2ERROR] := NOT #tempWithorWithoutCellDetections[1];
	                            IF #statLastScratch AND #tempCellSize = #"36SIZE" THEN
	                                _.Unit2.Alarms.errorStop[#WITHORWITHOUTDETECT3ERROR] := FALSE;
	                                _.Unit2.Alarms.errorStop[#WITHORWITHOUTDETECT4ERROR] := FALSE;
	                                #tempWithorWithoutCellDetections[2] := TRUE;
	                                #tempWithorWithoutCellDetections[3] := TRUE;
	                            ELSE
	                                _.Unit2.Alarms.errorStop[#WITHORWITHOUTDETECT3ERROR] := NOT #tempWithorWithoutCellDetections[2];
	                                _.Unit2.Alarms.errorStop[#WITHORWITHOUTDETECT4ERROR] := NOT #tempWithorWithoutCellDetections[3];
	                                
	                            END_IF;
	                            
	                        END_REGION
	                        IF #tempWithorWithoutCellDetections[0]
	                            AND
	                            #tempWithorWithoutCellDetections[1]
	                            AND
	                            #tempWithorWithoutCellDetections[2]
	                            AND
	                            #tempWithorWithoutCellDetections[3]
	                        THEN
	                            ControlNodes.sequence.status.nextStep := #STEP_106;
	                        END_IF;
	                        
	                    END_REGION
	                    
	                END_IF;
	                
	            #STEP_106:
	                REGION STEP_106 Z_move_liftup
	                    ControlNodes.cm3AxisControl.commandConfiguration.posAbsolute.position := 0;
	                    ControlNodes.cm3AxisControl.commands.posAbsolute := TRUE;
	                    IF _.LGF_CompareLReal(valueA := ControlNodes.cm3AxisControl.commandConfiguration.posAbsolute.position, valueB := ControlNodes.cm3AxisControl.monitoring.position) THEN
	                        ControlNodes.sequence.status.nextStep := #STEP_107;
	                    END_IF;
	                END_REGION
	                
	            #STEP_107:
	                REGION STEP107 TransferEnable to em2 
	                    
	                    REGION add ScratchCellIndex
	                        
	                        IF NOT #statStepFirstCall THEN
	                            
	                            IF #tempCellSize = #"36SIZE" AND #tempConstraintNextScratchCellIndex = 32 THEN
	                                
	                                #tempConstraintNextScratchCellIndex := #tempConstraintNextScratchCellIndex + 2;
	                            ELSE
	                                #tempConstraintNextScratchCellIndex := #tempConstraintNextScratchCellIndex + 4;
	                                ;
	                            END_IF;
	                            
	                            
	                        END_IF;
	                        
	                        _.Unit2.EmNodes.emRelations.EM4.deliver.constraintRoller.req.transferEnable := TRUE;
	                        #statStepFirstCall := true;
	                        
	                    END_REGION
	                    
	                    REGION plastic step OR ng conveyor step enable check
	                        #statPlasticStepEnable := FALSE;
	                        #statNgConveyorEnable := FALSE;
	                        IF #tempCellSize = #"36SIZE" AND #statLastScratch THEN
	                            #tempValidCellIndex := 3;
	                        ELSE
	                            #tempValidCellIndex := 1;
	                        END_IF;
	                        
	                        FOR #tempLoopIndex := 0 TO #tempValidCellIndex DO
	                            #statPlasticStepEnable := #statPlasticStepEnable OR #statScratchCellsInfo[#tempLoopIndex];
	                            IF #statPlasticStepEnable THEN
	                                EXIT;
	                                ;
	                            END_IF;
	                        END_FOR;
	                        FOR #tempLoopIndex := 0 TO #tempValidCellIndex DO
	                            #statNgConveyorEnable := #statNgConveyorEnable OR NOT #statScratchCellsInfo[#tempLoopIndex];
	                            IF #statNgConveyorEnable THEN
	                                EXIT;
	                                ;
	                            END_IF;
	                        END_FOR;
	                        
	                        IF #statPlasticStepEnable THEN
	                            ControlNodes.sequence.status.nextStep := #STEP_110;
	                            
	                        END_IF;
	                        IF #statNgConveyorEnable AND NOT #statPlasticStepEnable THEN
	                            ControlNodes.sequence.status.nextStep := #STEP_120;
	                            
	                        END_IF;
	                        
	                    END_REGION
	                    
	                    
	                END_REGION
	                
	                
	                REGION ##########Plastic
	                    // Statement section REGION
	                    
	                END_REGION
	                
	            #STEP_110:
	                REGION STEP_110 PalsticMoving
	                    REGION position update
	                        REGION 24 size setting
	                            IF #tempCellSize = #"24SIZE" THEN
	                                REGION position Settins
	                                    //y
	                                    _.Unit2.EM4.ControlNodes.cm2AxisControl.commandConfiguration.posAbsolute.position :=
	                                    Config.em4Parameters.cm2Axis120.production.distanceList[10 + #statyDistanceIndex].position;
	                                    //z
	                                    _.Unit2.EM4.ControlNodes.cm3AxisControl.commandConfiguration.posAbsolute.position :=
	                                    Config.em4Parameters.cm3Axis121.production.distanceList[10].position;
	                                    //x
	                                    _.Unit2.EM4.ControlNodes.cm1AxisControl.commandConfiguration.posAbsolute.position :=
	                                    Config.em4Parameters.cm1Axis119.production.distanceList[50 + #statxDistanceIndex].position;
	                                    
	                                END_REGION
	                                
	                            END_IF;
	                            
	                        END_REGION
	                        
	                        REGION 36 size setting
	                            IF #tempCellSize = #"36SIZE" THEN
	                                REGION position settings
	                                    //y
	                                    _.Unit2.EM4.ControlNodes.cm2AxisControl.commandConfiguration.posAbsolute.position :=
	                                    Config.em4Parameters.cm2Axis120.production.distanceList[13 + #statyDistanceIndex].position;
	                                    //z
	                                    _.Unit2.EM4.ControlNodes.cm3AxisControl.commandConfiguration.posAbsolute.position :=
	                                    Config.em4Parameters.cm3Axis121.production.distanceList[13].position;
	                                    //x
	                                    _.Unit2.EM4.ControlNodes.cm1AxisControl.commandConfiguration.posAbsolute.position :=
	                                    Config.em4Parameters.cm1Axis119.production.distanceList[60 + #statxDistanceIndex].position;
	                                    
	                                END_REGION
	                                
	                                
	                            END_IF;
	                        END_REGION
	                        
	                    END_REGION
	                    REGION cms cmd
	                        ControlNodes.cm1AxisControl.commands.posAbsolute := true;
	                        ControlNodes.cm2AxisControl.commands.posAbsolute := true;
	                        #tempCm1PosDone := _.LGF_CompareLReal(valueA := ControlNodes.cm1AxisControl.commandConfiguration.posAbsolute.position, valueB := ControlNodes.cm1AxisControl.monitoring.position);
	                        #tempCm2PosDone := _.LGF_CompareLReal(valueA := ControlNodes.cm2AxisControl.commandConfiguration.posAbsolute.position, valueB := ControlNodes.cm2AxisControl.monitoring.position);
	                        IF #tempCm1PosDone AND #tempCm2PosDone THEN
	                            ControlNodes.sequence.status.nextStep := #STEP_111;
	                        END_IF;
	                    END_REGION
	                END_REGION
	            #STEP_111:
	                REGION STEP_111 waiting em5 transferEnable
	                    IF _.Unit2.EmNodes.emRelations.EM4.recieve.plasticRoller.req.transferEnable THEN
	                        REGION z_move_liftdown
	                            
	                            ControlNodes.cm3AxisControl.commands.posAbsolute := TRUE;
	                            IF _.LGF_CompareLReal(valueA := ControlNodes.cm3AxisControl.commandConfiguration.posAbsolute.position, valueB := ControlNodes.cm3AxisControl.monitoring.position) THEN
	                                ControlNodes.sequence.status.nextStep := #STEP_112;
	                            END_IF;
	                        END_REGION
	                        
	                        ;
	                    END_IF;
	                    
	                    
	                END_REGION ;
	            #STEP_112:
	                REGION STEP_112 put down cells, the Cylinder go On Home
	                    
	                    #tempCm4Enable := #statScratchCellsInfo[0];
	                    #tempCm5Enable := #statScratchCellsInfo[1];
	                    
	                    IF #tempCellSize = #"36SIZE" AND #statLastScratch THEN
	                        #tempCm6Enable := FALSE;
	                        #tempCm7Enable := FALSE;
	                    ELSE
	                        #tempCm6Enable := #statScratchCellsInfo[2];
	                        #tempCm7Enable := #statScratchCellsInfo[3];
	                    END_IF;
	                    #statCylinderHomeDone := false;
	                    EXCHANGETRAY_Em4CylindersOperate(goHome := NOT #statCylinderHomeDone,
	                                                     goWork := FALSE,
	                                                     cm4Enable := #tempCm4Enable,
	                                                     cm5Enable := #tempCm5Enable,
	                                                     cm6Enable := #tempCm6Enable,
	                                                     cm7Enable := #tempCm7Enable,
	                                                     homeDone => #statCylinderHomeDone,
	                                                     workDone => #statCylinderWorkDone);
	                    
	                END_REGION
	                IF #statCylinderHomeDone THEN
	                    ControlNodes.sequence.status.nextStep := #STEP_113;
	                    ;
	                END_IF;
	                ;
	            #STEP_113:
	                REGION STEP_113 Z move liftup
	                    ControlNodes.cm3AxisControl.commandConfiguration.posAbsolute.position := 0;
	                    ControlNodes.cm3AxisControl.commands.posAbsolute := TRUE;
	                    
	                    IF _.LGF_CompareLReal(valueA := ControlNodes.cm3AxisControl.commandConfiguration.posAbsolute.position, valueB := ControlNodes.cm3AxisControl.monitoring.position) THEN
	                        REGION add plasticScratchCellIndex
	                            
	                            IF NOT #statStepFirstCall THEN
	                                #statRowTwoOn := NOT #statRowTwoOn;
	                                IF #tempCellSize = #"36SIZE" AND #statPlasticNextScratchCellIndex >= 32 THEN
	                                    
	                                    #statPlasticNextScratchCellIndex := #statPlasticNextScratchCellIndex + 2;
	                                ELSE
	                                    #statPlasticNextScratchCellIndex := #statPlasticNextScratchCellIndex + 4;
	                                    ;
	                                END_IF;
	                                
	                                
	                            END_IF;
	                            
	                            
	                            #statStepFirstCall := true;
	                            
	                        END_REGION
	                        
	                        IF #statNgConveyorEnable THEN
	                            ControlNodes.sequence.status.nextStep := #STEP_120;
	                            
	                        ELSE
	                            ControlNodes.sequence.status.nextStep := #STEP_130;
	                            
	                        END_IF;
	                    END_IF;
	                END_REGION
	                
	                REGION ######NG conveyor
	                    // Statement section REGION
	                    
	                END_REGION
	                
	                
	            #STEP_120:
	                REGION STEP_120 Ngconveyor Moving
	                    REGION position update
	                        //y
	                        _.Unit2.EM4.ControlNodes.cm2AxisControl.commandConfiguration.posAbsolute.position :=
	                        Config.em4Parameters.cm2Axis120.production.distanceList[20].position;
	                        //z
	                        _.Unit2.EM4.ControlNodes.cm3AxisControl.commandConfiguration.posAbsolute.position :=
	                        Config.em4Parameters.cm3Axis121.production.distanceList[20].position;
	                        //x
	                        _.Unit2.EM4.ControlNodes.cm1AxisControl.commandConfiguration.posAbsolute.position :=
	                        Config.em4Parameters.cm1Axis119.production.distanceList[20].position;
	                        
	                    END_REGION
	                    REGION cms cmd
	                        ControlNodes.cm1AxisControl.commands.posAbsolute := true;
	                        ControlNodes.cm2AxisControl.commands.posAbsolute := true;
	                        #tempCm1PosDone := _.LGF_CompareLReal(valueA := ControlNodes.cm1AxisControl.commandConfiguration.posAbsolute.position, valueB := ControlNodes.cm1AxisControl.monitoring.position);
	                        #tempCm2PosDone := _.LGF_CompareLReal(valueA := ControlNodes.cm2AxisControl.commandConfiguration.posAbsolute.position, valueB := ControlNodes.cm2AxisControl.monitoring.position);
	                        IF #tempCm1PosDone AND #tempCm2PosDone THEN
	                            ControlNodes.sequence.status.nextStep := #STEP_121;
	                        END_IF;
	                    END_REGION
	                END_REGION
	            #STEP_121:
	                REGION STEP_121 waiting ngconveyor transferEnable
	                    IF _.Unit2.EmNodes.emRelations.EM4.recieve.NgConvyorRoller.req.transferEnable THEN
	                        REGION z_move_liftdown
	                            
	                            ControlNodes.cm3AxisControl.commands.posAbsolute := TRUE;
	                            IF _.LGF_CompareLReal(valueA := ControlNodes.cm3AxisControl.commandConfiguration.posAbsolute.position, valueB := ControlNodes.cm3AxisControl.monitoring.position) THEN
	                                ControlNodes.sequence.status.nextStep := #STEP_122;
	                            END_IF;
	                        END_REGION
	                        
	                        ;
	                    END_IF;
	                    
	                    
	                END_REGION ;
	            #STEP_122:
	                REGION STEP_122 waiting put down cells ,the Cylinder go On Home
	                    //
	                    #tempCm4Enable := NOT #statScratchCellsInfo[0];
	                    #tempCm5Enable := NOT #statScratchCellsInfo[1];
	                    //
	                    IF #tempCellSize = #"36SIZE" AND #statLastScratch THEN
	                        #tempCm6Enable := FALSE;
	                        #tempCm7Enable := FALSE;
	                    ELSE
	                        #tempCm6Enable := NOT #statScratchCellsInfo[2];
	                        #tempCm7Enable := NOT #statScratchCellsInfo[3];
	                    END_IF;
	                    #statCylinderHomeDone := false;
	                    EXCHANGETRAY_Em4CylindersOperate(goHome := NOT #statCylinderHomeDone,
	                                                     goWork := FALSE,
	                                                     cm4Enable := #tempCm4Enable,
	                                                     cm5Enable := #tempCm5Enable,
	                                                     cm6Enable := #tempCm6Enable,
	                                                     cm7Enable := #tempCm7Enable,
	                                                     homeDone => #statCylinderHomeDone,
	                                                     workDone => #statCylinderWorkDone);
	                    IF #statCylinderHomeDone THEN
	                        ControlNodes.sequence.status.nextStep := #STEP_123;
	                        ;
	                    END_IF;
	                    
	                END_REGION
	                
	                
	            #STEP_123:
	                REGION STEP_123 Z move liftup
	                    ControlNodes.cm3AxisControl.commandConfiguration.posAbsolute.position := 0;
	                    ControlNodes.cm3AxisControl.commands.posAbsolute := TRUE;
	                    IF _.LGF_CompareLReal(valueA := ControlNodes.cm3AxisControl.commandConfiguration.posAbsolute.position, valueB := ControlNodes.cm3AxisControl.monitoring.position) THEN
	                        
	                        ControlNodes.sequence.status.nextStep := #STEP_130;
	                    END_IF;
	                END_REGION
	                
	            #STEP_130:
	                REGION STEP_130
	                    IF #tempConstraintNextScratchCellIndex >= #tempCellSize
	                        
	                    THEN
	                        _.Unit2.EmNodes.emRelations.EM4.deliver.plasticRoller.req.transferEnable := TRUE;
	                        ControlNodes.sequence.status.nextStep := #STEP_IDLE;
	                    ELSE
	                        
	                        ControlNodes.sequence.status.nextStep := #STEP_102;
	                    END_IF;
	                    
	                END_REGION
	                ;
	                
	                
	                REGION ########STEP_IMMEDIATE_STOP
	                    // Statement section REGION
	                    
	                END_REGION
	                
	            #STEP_IMMEDIATE_STOP:
	                #statStepFirstCall := FALSE;
	                ControlNodes.cm1AxisControl.commands.stop := TRUE;
	                ControlNodes.cm2AxisControl.commands.stop := TRUE;
	                ControlNodes.cm3AxisControl.commands.stop := TRUE;
	                IF ControlNodes.jobs.commands.setJobNumber = _.U2EM4_JOB_EXECUTE THEN
	                    #instRecordRecoverStep.step := ControlNodes.sequence.previousSteps[2].step;
	                    #instRecordRecoverStep.saveRecord := true;
	                END_IF;
	                IF #instRecordRecoverStep.saveDone THEN
	                    #instRecordRecoverStep.saveRecord := FALSE;
	                END_IF;
	                
	                IF ControlNodes.cm1AxisControl.monitoring.statusWord.bit06_Done
	                    AND
	                    ControlNodes.cm1AxisControl.monitoring.statusWord.bit06_Done
	                    AND
	                    ControlNodes.cm1AxisControl.monitoring.statusWord.bit06_Done
	                THEN
	                    ControlNodes.sequence.status.nextStep := #STEP_IDLE;
	                    ;
	                END_IF;
	                
	        END_CASE;
	    END_IF;
	END_REGION Steps
	
	REGION Status updates      
	    REGION Sequence Status
	        // Update the status
	        #instSequenceSCLStatus(parentReferenceDesignator := Config.em.referenceDesignator.combined,
	                               idleStep := #STEP_IDLE,
	                               stoppedStep := #STEP_IMMEDIATE_STOP,
	                               setJobNumber := ControlNodes.jobs.commands.setJobNumber,
	                               activeJobNumber => ControlNodes.jobs.status.activeJobNumber,
	                               previousCycleJobNumber => ControlNodes.jobs.status.previousCycleJobNumber,
	                               hmiInterface := HmiInterface.sequence,
	                               sequence := ControlNodes.sequence);
	    END_REGION Sequence Status
	    
	    
	    REGION Update Job History
	        // Update the History of jobs if a new job was started
	        IF (ControlNodes.jobs.status.activeJobNumber <> ControlNodes.jobs.status.previousCycleJobNumber) THEN
	            _.LAF_UpdateJobHistory(jobs := ControlNodes.jobs);
	        END_IF;
	    END_REGION
	    
	    REGION Output steps as String
	        // Write outputs as strings 
	        ControlNodes.sequence.status.currentStepSTRING := StepToString(ControlNodes.sequence.status.currentStep);
	        ControlNodes.sequence.status.previousStepSTRING := StepToString(ControlNodes.sequence.status.previousStep);
	        ControlNodes.sequence.status.nextStepSTRING := StepToString(ControlNodes.sequence.status.nextStep);
	    END_REGION Output steps as String   
	    
	    REGION output
	        _.Global.Data.material.Unit2.contraint.monitor.cellsInfo.nextScratchCellIndex := #tempConstraintNextScratchCellIndex;
	        #instRecordRecoverStep(step := ControlNodes.sequence.status.currentStep,
	                               cm1AxisControl := ControlNodes.cm1AxisControl,
	                               cm2AxisControl := ControlNodes.cm1AxisControl,
	                               cm3AxisControl := ControlNodes.cm1AxisControl,
	                               cm4Cylinder := ControlNodes.cm4Cylinder,
	                               cm5Cylinder := ControlNodes.cm4Cylinder,
	                               cm6Cylinder := ControlNodes.cm4Cylinder,
	                               cm7Cylinder := ControlNodes.cm4Cylinder);
	        _.Unit2.EmNodes.emRelations.EM4.deliver.NgConvyorRoller.req.transferEnable := _.LGF_CompareLReal(valueA := ControlNodes.cm3AxisControl.monitoring.position, valueB := 0.0);
	        
	    END_REGION
	    
	END_REGION Status updates
	
END_FUNCTION_BLOCK
END_NAMESPACE

